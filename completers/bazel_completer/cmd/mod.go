package cmd

import (
	"github.com/carapace-sh/carapace"
	"github.com/spf13/cobra"
)

var modCmd = &cobra.Command{
	Use:   "mod",
	Short: "Queries the Bzlmod external dependency graph",
	Run:   func(cmd *cobra.Command, args []string) {},
}

func init() {
	carapace.Gen(modCmd).Standalone()

	modCmd.Flags().Bool("base_module", false, "Specify a module relative to which the specified target repos will be interpreted.")
	modCmd.Flags().Bool("charset", false, "Chooses the character set to use for the tree. Only affects text output. Valid values are \"utf8\" or \"ascii\". Default is \"utf8\"")
	modCmd.Flags().Bool("cycles", false, "Points out dependency cycles inside the displayed tree, which are normally ignored by default.")
	modCmd.Flags().Bool("default_visibility", false, "Default visibility for packages that don't set it explicitly ('public' or 'private').")
	modCmd.Flags().Bool("deleted_packages", false, "A comma-separated list of names of packages which the build system will consider non-existent, even if they are visible somewhere on the package path.")
	modCmd.Flags().Bool("depth", false, "Maximum display depth of the dependency tree. A depth of 1 displays the direct dependencies, for example. For tree, path and all_paths it defaults to Integer.MAX_VALUE, while for deps and explain it defaults to 1 (only displays direct deps of the root besides the target leaves and their parents).")
	modCmd.Flags().Bool("experimental_check_output_files", false, "Check for modifications made to the output files of a build. Consider setting this flag to false if you don't expect these files to change outside of bazel since it will speed up subsequent runs as they won't have to check a previous run's cache.")
	modCmd.Flags().Bool("experimental_max_directories_to_eagerly_visit_in_globbing", false, "If non-negative, the first time a glob is evaluated in a package, the subdirectories of the package will be traversed in order to warm filesystem caches and compensate for lack of parallelism in globbing. At most this many directories will be visited.")
	modCmd.Flags().Bool("extension_filter", false, "Only display the usages of these module extensions and the repos generated by them if their respective flags are set. If set, the result graph will only include paths that contain modules using the specified extensions. An empty list disables the filter, effectively specifying all possible extensions.")
	modCmd.Flags().Bool("extension_info", false, "Specify how much detail about extension usages to include in the query result. \"Usages\" will only show the extensions names, \"repos\" will also include repos imported with use_repo, and \"all\" will also show the other repositories generated by extensions.")
	modCmd.Flags().Bool("extension_usages", false, "Specify modules whose extension usages will be displayed in the show_extension query.")
	modCmd.Flags().Bool("fetch", false, "Allows the command to fetch external dependencies. If set to false, the command will utilize any cached version of the dependency, and if none exists, the command will result in failure.")
	modCmd.Flags().Bool("from", false, "The module(s) starting from which the dependency graph query will be displayed. Check each queryâ€™s description for the exact semantics. Defaults to <root>.")
	modCmd.Flags().Bool("include_builtin", false, "Include built-in modules in the dependency graph. Disabled by default because it is quite noisy.")
	modCmd.Flags().Bool("include_unused", false, "The queries will also take into account and display the unused modules, which are not present in the module resolution graph after selection (due to the Minimal-Version Selection or override rules). This can have different effects for each of the query types i.e. include new paths in the all_paths command, or extra dependants in the explain command.")
	modCmd.Flags().Bool("incompatible_config_setting_private_default_visibility", false, "If incompatible_enforce_config_setting_visibility=false, this is a noop. Else, if this flag is false, any config_setting without an explicit visibility attribute is //visibility:public. If this flag is true, config_setting follows the same visibility logic as all other rules. See https://github.com/bazelbuild/bazel/issues/12933.")
	modCmd.Flags().Bool("incompatible_enforce_config_setting_visibility", false, "If true, enforce config_setting visibility restrictions. If false, every config_setting is visible to every target. See https://github.com/bazelbuild/bazel/issues/12932.")
	modCmd.Flags().Bool("legacy_globbing_threads", false, "Number of threads to use for glob evaluation. Takes an integer, or a keyword (\"auto\", \"HOST_CPUS\", \"HOST_RAM\"), optionally followed by an operation ([-|*]<float>) eg. \"auto\", \"HOST_CPUS*.5\". \"auto\" means to use a reasonable value derived from the machine's hardware profile (e.g. the number of processors).")
	modCmd.Flags().Bool("loading_phase_threads", false, "Number of parallel threads to use for the loading/analysis phase.Takes an integer, or a keyword (\"auto\", \"HOST_CPUS\", \"HOST_RAM\"), optionally followed by an operation ([-|*]<float>) eg. \"auto\", \"HOST_CPUS*.5\". \"auto\" sets a reasonable default based on host resources. Must be at least 1.")
	modCmd.Flags().Bool("nocycles", false, "Points out dependency cycles inside the displayed tree, which are normally ignored by default.")
	modCmd.Flags().Bool("noexperimental_check_output_files", false, "Check for modifications made to the output files of a build. Consider setting this flag to false if you don't expect these files to change outside of bazel since it will speed up subsequent runs as they won't have to check a previous run's cache.")
	modCmd.Flags().Bool("nofetch", false, "Allows the command to fetch external dependencies. If set to false, the command will utilize any cached version of the dependency, and if none exists, the command will result in failure.")
	modCmd.Flags().Bool("noinclude_builtin", false, "Include built-in modules in the dependency graph. Disabled by default because it is quite noisy.")
	modCmd.Flags().Bool("noinclude_unused", false, "The queries will also take into account and display the unused modules, which are not present in the module resolution graph after selection (due to the Minimal-Version Selection or override rules). This can have different effects for each of the query types i.e. include new paths in the all_paths command, or extra dependants in the explain command.")
	modCmd.Flags().Bool("noincompatible_config_setting_private_default_visibility", false, "If incompatible_enforce_config_setting_visibility=false, this is a noop. Else, if this flag is false, any config_setting without an explicit visibility attribute is //visibility:public. If this flag is true, config_setting follows the same visibility logic as all other rules. See https://github.com/bazelbuild/bazel/issues/12933.")
	modCmd.Flags().Bool("noincompatible_enforce_config_setting_visibility", false, "If true, enforce config_setting visibility restrictions. If false, every config_setting is visible to every target. See https://github.com/bazelbuild/bazel/issues/12932.")
	modCmd.Flags().Bool("noshow_loading_progress", false, "If enabled, causes Bazel to print \"Loading package:\" messages.")
	modCmd.Flags().Bool("noverbose", false, "The queries will also display the reason why modules were resolved to their current version (if changed). Defaults to true only for the explain query.")
	modCmd.Flags().Bool("output", false, "The format in which the query results should be printed. Allowed values for query are: text, json, graph")
	modCmd.Flags().Bool("package_path", false, "A colon-separated list of where to look for packages. Elements beginning with '%workspace%' are relative to the enclosing workspace. If omitted or empty, the default is the output of 'bazel info default-package-path'.")
	modCmd.Flags().Bool("show_loading_progress", false, "If enabled, causes Bazel to print \"Loading package:\" messages.")
	modCmd.Flags().Bool("verbose", false, "The queries will also display the reason why modules were resolved to their current version (if changed). Defaults to true only for the explain query.")
	rootCmd.AddCommand(modCmd)
}
